<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
	</body>
	<script>
		//做饭 
		function startCook(){ 
			console.log('开始做饭中...')
			return new Promise(function(resolve, reject){ //做一些异步操作
			  setTimeout(function(){ 
				console.log('做饭完毕！')
				resolve('鸡蛋炒饭'); 
				// reject('错了')
			  }, 1000)
			}); 
			
		} 

		//吃饭 
		function eat(data){
			console.log('开始吃饭中...：菜是' + data) 
			return new Promise(function(resolve, reject){ //做一些异步操作 
			  setTimeout(function(){
				console.log('吃饭完毕!')
				resolve('一只碗和一双筷子')
			  }, 1001) 
			})
			
		} 

		// 洗碗
		function wash(data){ 
			console.log('开始洗碗中...：' + data)
			return new Promise(function(resolve, reject){ //做一些异步操作 
			  setTimeout(function(){ 
				console.log('洗碗完毕!')
				resolve('干净的碗筷')
			  }, 1002)
			}); 
			 
		}
		// 处理错误信息
		function catchFn(err){
		  console.log('错误信息：' + err)
		  return err
		}
		  
		  
		Promise.all([startCook(),eat(),wash()]).then((result) => {
		  console.log(result)       // [ '3秒后醒来', '2秒后醒来' ]
		}).catch((error) => {
		  console.log(error)
		})
		/////////////////////////////////////////////////////////////////////////////
		
		let wake = (time) => {
		  return new Promise((resolve, reject) => {
		    setTimeout(() => {
		      resolve(`${time / 1000}秒后醒来`)
		    }, time)
		  })
		}
		
		let p1 = wake(3000)
		let p2 = wake(2000)
		
		Promise.all([p1, p2]).then((result) => {
		  console.log(result)       // [ '3秒后醒来', '2秒后醒来' ]
		}).catch((error) => {
		  console.log(error)
		})

	</script>
	
	<script>
		/**
		 1 Promise.all([p1(), p2()])  本身也会返回一个promise对象
		 
		 2 Promise.all可以将多个Promise实例包装成一个新的Promise实例。
		 同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。
		 
		 3 Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，
		 即p1的结果在前，即便p1的结果获取的比p2要晚。
		 这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，
		 使用Promise.all毫无疑问可以解决这个问题。
		 
		*/
		
	</script>
</html>


